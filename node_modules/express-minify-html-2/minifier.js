'use strict'

const { minify } = require('html-minifier-terser')

const toArrayIfNotAlreadyAnArray = (value) => {
  return Array.isArray(value) ? value : [value]
}

const any = (fn, values) => {
  for (let value of values) {
    if (fn(value)) {
      return true
    }
  }

  return false
}

const none = (fn, values) => {
  return !any(fn, values)
}

const propOr = (key, fallbackValue, obj) => {
  if (typeof obj === 'object' && typeof obj[key] !== 'undefined') {
    return obj[key]
  }

  return fallbackValue
}

const parseOptions = (options) => ({
  override: propOr('override', false, options),
  exceptionUrls: toArrayIfNotAlreadyAnArray(propOr('exceptionUrls', propOr('exception_url', false, options), options)),
  htmlMinifier: Object.assign(
    {
      removeComments: true,
      collapseWhitespace: true,
      collapseBooleanAttributes: true,
      removeAttributeQuotes: true,
      removeEmptyAttributes: true,
    },
    propOr('htmlMinifier', {}, options),
  ),
})

const matchesException = (req, res) => {
  return (exception) => {
    if (exception instanceof RegExp) {
      return exception.test(req.url)
    }

    if (typeof exception === 'function') {
      return exception(req, res) || false
    }

    if (typeof exception === 'string') {
      return req.url.match(exception) !== null
    }

    return false
  }
}

const sendMinified = (res, next, htmlMinifierOptions, callback) => {
  if (typeof callback === 'undefined') {
    // No callback specified, just minify and send to client.
    return (err, html) => {
      if (err) {
        return next(err)
      }

      minify(html, htmlMinifierOptions)
        .then((html) => {
          res.send(html)
        })
        .catch((err) => {
          res.status(500).send(err)
        })
    }
  }

  // Custom callback specified by user, use that one
  return (err, html) => {
    if (!html) {
      callback(err, html)
      return
    }

    minify(html, htmlMinifierOptions)
      .then((html) => {
        callback(err, html)
      })
      .catch((err) => {
        callback(err)
      })
  }
}

module.exports = (options = {}) => {
  const { override, exceptionUrls, htmlMinifier } = parseOptions(options)

  return (req, res, next) => {
    res.renderMin = function (view, renderOpts, callback) {
      this.render(view, renderOpts, sendMinified(res, next, htmlMinifier, callback))
    }

    if (override && none(matchesException(req, res), exceptionUrls)) {
      res.oldRender = res.render
      res.render = function (view, renderOpts, callback) {
        this.oldRender(view, renderOpts, sendMinified(res, next, htmlMinifier, callback))
      }
    }

    return next()
  }
}
